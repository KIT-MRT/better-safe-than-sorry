% !TeX root = ../root.tex
% -*- root: ../root.tex -*-

\section{Fundamentals}

\subsection{Decision-Making}

Decision making is a crucial part of a robot's planning module.
Based on the current situation, it determines a command, trajectory or maneuver to be executed.
Various methods have been established in the literature, ranging from pure decision making to situation-specific trajectory planning.

Rule-based methods, such as finite state machines, behavior trees, or arbitration graphs, address decision making through discrete state or mode transitions.
Graph-based or search-based methods like A*, Probabilistic Roadmaps (PRM*), and Rapidly-exploring Random Trees (RRT*) are popular in path planning for mobile robots but can also be used for decision making.
In trajectory planning, probabilistic methods like Partially Observable Markov Decision Processes (POMDPs) and machine learning techniques, including reinforcement learning, are increasingly employed.
These methods often make implicit decisions, such as when and where to change paths.

This section focuses on rule-based methods, including classical state-based methods like finite state machines, as well as behavior-based methods like behavior trees and arbitration graphs.
\todo{Fix references}
For a comprehensive overview of methods, refer to [Sch18, Yur20, Vo√ü21, Gam21], with a more detailed version of this section available in [Orz23].
Rule-based methods are particularly prevalent for prototypes used by smaller research groups due to their ease of application, numerous freely available software frameworks [Sch14, Bur18, Gre21b, The20b], including direct integration with MATLAB [The20a], and their standardization in the Unified Modeling Language [Obj17].

\subsection{Finite State Machines}

\subsubsection*{Introduction:}
\begin{itemize}
    \item Originated in hardware design and theoretical computer science
    \item Now used in robotics and driver assistance systems
    \item Easy to understand and implement
\end{itemize}

\subsubsection*{Basic concepts:}
\begin{itemize}
    \item A finite state machine consists of:
          \begin{itemize}
              \item A finite set of states $S$
              \item A finite set of input symbols (events) $\Sigma$
              \item A finite set of output symbols (actions) $\Delta$
              \item A state transition function $\delta:S \times \Sigma \to S$
              \item An output function $\lambda:S \to \Delta$
              \item A start state $s_0 \in S$
              \item A finite set of final states $F \subseteq S$
          \end{itemize}
    \item The FSM starts in the start state $s_0$
    \item For each event $e_i \in \Sigma$, it transitions to a new state $s_{i+1} = \delta(s_i, e_i)$
    \item After each transition, it outputs $a_i = \lambda(s_i)$
    \item FSMs can be represented graphically using UML state diagrams
\end{itemize}

\todo[inline]{Replace with Pacman example}
\subsubsection*{Example: FSM used by the Stanford Junior team in the DARPA Urban Challenge}
\begin{itemize}
    \item States represent tactical driving maneuvers (e.g., follow, overtake, park)
    \item Transitions are triggered by situation interpretation
    \item FSM is effective for simple behavior problems but scales poorly with complexity
\end{itemize}

\subsubsection*{Advantages:}
\begin{itemize}
    \item Easy to implement and understand
    \item Intuitive graphical representation
\end{itemize}

\subsubsection*{Disadvantages:}
\begin{itemize}
    \item Poor scalability for complex systems
    \item Difficult to modify
    \item Difficult to understand and verify source code
    \item Visualizations of complex systems can become cluttered
\end{itemize}

\subsection{Behavior Trees}

\subsubsection*{Introduction:}
\begin{itemize}
    \item Originally designed for computer game development
    \item Increasingly used in robotics applications since 2012
    \item Only one published work in the field of driver assistance systems or automated vehicles (Olsson, 2016)
\end{itemize}

\subsubsection*{Basic concepts:}
\begin{itemize}
    \item A behavior tree is a connected, loop-free, undirected graph
    \item Internal nodes (control flow nodes) determine the selection mechanism
    \item Leaves represent possible behaviors (action nodes) and conditions (condition nodes)
    \item Behavior decision is timer-based, not event-based
    \item Tree structure determines decision-making
    \item Tree is evaluated from the root node at a fixed frequency
    \item Each node returns a value indicating whether it is still running, has been completed successfully, or has failed
    \item Different types of control flow nodes are available, e.g., for sequences, fallback structures, and concurrency
    \item Condition nodes return a value indicating whether the underlying condition is met
    \item Action nodes execute the corresponding behavior and return a value indicating the status of that behavior
\end{itemize}

\todo[inline]{Replace with Pacman example}
\subsubsection*{Example: Behavior tree for an interactive humanoid entertainment robot (simplified from Colledanchise, 2018)}
\begin{itemize}
    \item Robot can sit down, stand up, play ball, or say goodbye on request
    \item Each action is linked to its corresponding condition node
    \item The modular hierarchical structure of the tree allows for a subdivision into subtasks
\end{itemize}

\subsubsection*{Advantages:}
\begin{itemize}
    \item Modular
    \item Hierarchically organized
    \item Reusable components
    \item Responsive
    \item Interpretable
\end{itemize}

\subsubsection*{Disadvantages:}
\begin{itemize}
    \item Can become large and difficult to understand for complex problems
    \item Safety depends on the arrangement of the nodes in the tree
\end{itemize}

\subsection*{Arbitration Graphs}

\begin{itemize}
    \item Developed for robot soccer.
    \item Combines ideas from Brooks' subsumption architecture, knowledge-based architectures, and object-oriented programming.
    \item Goals:
          \begin{itemize}
              \item Achieve low reaction times.
              \item Compose known game tactics from simple building blocks.
              \item Combine deliberative components with machine learning approaches.
              \item Develop a modular software framework that is incrementally expandable, has clear interfaces, and leads to a transparent decision-making process.
          \end{itemize}
\end{itemize}

\subsubsection*{Concept}
\begin{itemize}
    \item Based on atomic behavior modules that represent simple skills and behaviors.
    \item Complex system behavior, such as tactics and strategies, emerges from the interaction of numerous simple behavior modules.
    \item These are combined into more complex system behavior, i.e., tactics to strategies, using arbitrators according to the subsumption principle.
    \item Instead of breaking down a problem into subproblems in a top-down knowledge-based approach, complex behavior is iteratively composed from simple behavior competences in a bottom-up design.
\end{itemize}

\subsubsection*{Behavior modules}
\begin{itemize}
\item Input to the behavior modules is the current situation $\situation$ of the environment.
\item This is mapped to actor-related control variables $\command$ using the \emph{control function} \texttt{getCommand}:

$\text{command} = \text{getCommand}(\text{situation})$

\item In robot soccer, $\command$ consists of the desired longitudinal and angular velocity of a player as well as instructions for his shooting device.
\item To enable not only reactive but also deliberative behavior, the behavior modules can create situation and command histories or use randomized procedures.
\end{itemize}

\subsubsection*{Start and continue conditions}
\begin{itemize}
    \item Each \emph{behavior module} determines, in addition to its actual action, whether its preconditions are met and the behavior is therefore currently applicable at all using the so-called \emph{start condition} $\invCond$.
    \item A soccer player can only dribble the ball towards the goal, for example, if he is actually in possession of the ball.
    \item If a behavior module is active, it also returns whether all conditions are met to continue the behavior using the \emph{continue condition} $\comCond$.
    \item Because the player can only dribble on as long as he does not lose the ball or has reached the dribbling target.
    \item Or a more promising behavior such as a shot becomes possible.
    \item Each behavior module thus determines itself, using the start and continue conditions, whether it is applicable in the given situation.
    \item Therefore, the calling instance itself does not need any knowledge of the prerequisites for executing a behavior module.
\end{itemize}


\subsubsection*{Behavior generation}
Generic \emph{arbitrators} combine a set of behavior modules, also referred to as options here, into a tactic
\begin{itemize}
\item First, the current situation $\situation$ is determined from the latest input data and is made available to the behavior modules
\item Next, the arbitrator determines its best applicable action
\item To do this, it filters out those options $\applicableOptions$ from its options $\options$ that are currently applicable or fall within the domain of the current situation
\item The behavior modules signal this via their start and continue conditions

\item From the applicable options $\applicableOptions$, the arbitrator finally selects the best possible option, defines it as its intention $\intention$
\end{itemize}

\subsection{Fault-tolerant/Robust Systems}

Fault-tolerant systems are designed to maintain a high level of reliability despite potential faults or errors. In such systems, faults, errors, and failures are distinguished. Measures to increase reliability can be categorized into fault prevention, removal, tolerance, and prediction. Fault tolerance is a key pillar of reliable systems and encompasses fault diagnosis and fault handling. Fault handling methods include error recovery, error passivation, and error compensation.

\subsection{Safe Behaviors}

\subsubsection*{Goal}
The goal of traffic safety is to ensure the absence of unreasonable risks when objects are moved in a (traffic) system.

\todo[inline]{Generalize the following}
\subsubsection*{Behavior Verification}
One of the challenges in traffic safety is verifying the safety of a planned behavior while considering uncertainties. A common method for behavior verification is the set-based approach with reachable sets analysis. This approach involves planning a fail-safe trajectory in addition to the intended trajectory. Worst-case occupancies are used to overapproximate possible behaviors of other traffic participants. The behavior is considered safe if the fail-safe trajectory does not overlap with worst-case occupancies. The benefits of this approach include provable safety under specified assumptions.

\subsubsection*{Overall Safety Approach}
An effective approach to ensuring traffic safety involves:
\begin{itemize}
    \item \textbf{Risk Analysis:} Identify and assess risks throughout the development process.
    \item \textbf{Verification and Validation:} Verify and validate safety at all levels, including hardware, behavior, and fleet.
    \item \textbf{Monitoring:} Continuously monitor risks during operation to ensure ongoing safety.
\end{itemize}
