% !TeX root = ../root.tex
% -*- root: ../root.tex -*-

\section{Fundamentals}
\subsection{Architectures for Automated Vehicles}

\subsubsection*{3-layer model for automated driving}
\begin{itemize}
    \item \textbf{Strategic layer:} Defines general long-term preferences and goals (e.g., planned route)
    \item \textbf{Tactical layer:} Generates driving maneuvers (e.g., lane change, stop maneuver) based on current situation and goals
    \item \textbf{Operational layer:} Actuates the intended maneuver with a high update frequency (e.g., milliseconds)
\end{itemize}

\subsubsection*{Architectures for automated vehicles}
\begin{itemize}
    \item \textbf{Processing chain:} Perception, prediction, behavior decision, trajectory planning, and control are performed in a decoupled manner
    \item \textbf{Integrated prediction:} Prediction is integrated into behavior and trajectory planning for planning interactive behavior
    \item \textbf{End-to-end planning:} The entire processing chain is interwoven into a common processing step (e.g., machine learning approaches)
\end{itemize}

\subsection{Decision-Making}

\begin{itemize}
    \item Part of the tactical layer: Makes the decision of which maneuver to drive based on the current situation
    \item Provides either constraints to the downstream trajectory planning or a set-point trajectory to the control
    \item Wide range of methods available:
          \begin{itemize}
              \item Rule-based methods (e.g., finite state machines, decision trees, arbitration graphs)
              \item Graph-based methods (e.g., A*, PRM*, RRT*)
              \item Probabilistic methods (e.g., POMDPs)
              \item Machine learning methods (e.g., reinforcement learning)
          \end{itemize}
\end{itemize}

Focus of this chapter: Rule-based methods

\begin{itemize}
    \item \textbf{Classical state-based methods:}
          \begin{itemize}
              \item Finite state machines (FSMs)
              \item Decision trees
          \end{itemize}

    \item \textbf{Behavior-based methods:}
          \begin{itemize}
              \item Behavior trees
              \item Arbitration graphs
          \end{itemize}
\end{itemize}

\subsubsection*{Finite State Machines}

\begin{itemize}
\item \textbf{Introduction:}
\begin{itemize}
    \item Originated in hardware design and theoretical computer science
    \item Now used in robotics and driver assistance systems
    \item Easy to understand and implement
\end{itemize}

\item \textbf{Basic concepts:}
\begin{itemize}
    \item A finite state machine consists of:
          \begin{itemize}
              \item A finite set of states $S$
              \item A finite set of input symbols (events) $\Sigma$
              \item A finite set of output symbols (actions) $\Delta$
              \item A state transition function $\delta:S \times \Sigma \to S$
              \item An output function $\lambda:S \to \Delta$
              \item A start state $s_0 \in S$
              \item A finite set of final states $F \subseteq S$
          \end{itemize}
    \item The FSM starts in the start state $s_0$
    \item For each event $e_i \in \Sigma$, it transitions to a new state $s_{i+1} = \delta(s_i, e_i)$
    \item After each transition, it outputs $a_i = \lambda(s_i)$
    \item FSMs can be represented graphically using UML state diagrams
\end{itemize}

\item \textbf{Example: FSM used by the Stanford Junior team in the DARPA Urban Challenge}
\begin{itemize}
    \item States represent tactical driving maneuvers (e.g., follow, overtake, park)
    \item Transitions are triggered by situation interpretation
    \item FSM is effective for simple behavior problems but scales poorly with complexity
\end{itemize}

\item \textbf{Advantages:}
\begin{itemize}
    \item Easy to implement and understand
    \item Intuitive graphical representation
\end{itemize}

\item \textbf{Disadvantages:}
\begin{itemize}
    \item Poor scalability for complex systems
    \item Difficult to modify
    \item Difficult to understand and verify source code
    \item Visualizations of complex systems can become cluttered
\end{itemize}
\end{itemize}

\subsubsection*{Decision Trees}

\begin{itemize}
\item \textbf{Introduction:}
\begin{itemize}
    \item Originally designed as recursive structures for describing classification rules
    \item Now used in a variety of applications, including machine learning and decision-making
\end{itemize}

\item \textbf{Basic concepts:}
\begin{itemize}
    \item Represented as directed ordered trees
    \item Nodes represent conditions in the form of discrete or Boolean decision variables $x_i$
    \item Leaves represent the resulting decisions $f(x_1, \ldots, x_n)$
    \item Evaluation starts at the root node and continues recursively until a leaf is reached
    \item Popular in practice due to their ease of implementation and intuitive representation
\end{itemize}

\item \textbf{Example: Decision trees used by BMW for highly automated driving on highways and an emergency stop assistant}
\begin{itemize}
    \item Two separate decision trees were designed, one for lateral and one for longitudinal control
    \item Decision variables were derived from situation interpretation, e.g., lane change request
    \item Leaves provided setpoints and constraints for downstream trajectory planning
\end{itemize}

\item \textbf{Advantages:}
\begin{itemize}
    \item Easy to implement and understand
    \item Modular and extensible
    \item Can handle both discrete and continuous decision variables
\end{itemize}

\item \textbf{Disadvantages:}
\begin{itemize}
    \item Can become large and difficult to interpret for complex problems
    \item Not well-suited for real-time applications due to their computational cost
    \item Do not provide any (success) status or other performance criteria
\end{itemize}
\end{itemize}

\subsubsection*{Behavior Trees}

\begin{itemize}
\item \textbf{Introduction:}
\begin{itemize}
    \item Originally designed for computer game development
    \item Increasingly used in robotics applications since 2012
    \item Only one published work in the field of driver assistance systems or automated vehicles (Olsson, 2016)
\end{itemize}

\item \textbf{Basic concepts:}
\begin{itemize}
    \item A behavior tree is a connected, loop-free, undirected graph
    \item Internal nodes (control flow nodes) determine the selection mechanism
    \item Leaves represent possible behaviors (action nodes) and conditions (condition nodes)
    \item Behavior decision is timer-based, not event-based
    \item Tree structure determines decision-making
    \item Tree is evaluated from the root node at a fixed frequency
    \item Each node returns a value indicating whether it is still running, has been completed successfully, or has failed
    \item Different types of control flow nodes are available, e.g., for sequences, fallback structures, and concurrency
    \item Condition nodes return a value indicating whether the underlying condition is met
    \item Action nodes execute the corresponding behavior and return a value indicating the status of that behavior
\end{itemize}

\item \textbf{Example: Behavior tree for an interactive humanoid entertainment robot (simplified from Colledanchise, 2018)}
\begin{itemize}
    \item Robot can sit down, stand up, play ball, or say goodbye on request
    \item Each action is linked to its corresponding condition node
    \item The modular hierarchical structure of the tree allows for a subdivision into subtasks
\end{itemize}

\item \textbf{Advantages:}
\begin{itemize}
    \item Modular
    \item Hierarchically organized
    \item Reusable components
    \item Responsive
    \item Interpretable
\end{itemize}

\item \textbf{Disadvantages:}
\begin{itemize}
    \item Can become large and difficult to understand for complex problems
    \item Safety depends on the arrangement of the nodes in the tree
\end{itemize}
\end{itemize}

\subsubsection*{Arbitration Graphs}

\begin{itemize}
    \item Developed for robot soccer.
    \item Combines ideas from Brooks' subsumption architecture, knowledge-based architectures, and object-oriented programming.
    \item Goals:
          \begin{itemize}
              \item Achieve low reaction times.
              \item Compose known game tactics from simple building blocks.
              \item Combine deliberative components with machine learning approaches.
              \item Develop a modular software framework that is incrementally expandable, has clear interfaces, and leads to a transparent decision-making process.
          \end{itemize}
\end{itemize}

\paragraph*{Concept}
\begin{itemize}
    \item Based on atomic behavior modules that represent simple skills and behaviors.
    \item Complex system behavior, such as tactics and strategies, emerges from the interaction of numerous simple behavior modules.
    \item These are combined into more complex system behavior, i.e., tactics to strategies, using arbitrators according to the subsumption principle.
    \item Instead of breaking down a problem into subproblems in a top-down knowledge-based approach, complex behavior is iteratively composed from simple behavior competences in a bottom-up design.
\end{itemize}

\paragraph*{Behavior modules}
\begin{itemize}
\item Input to the behavior modules is the current situation $\situation$ of the environment.
\item This is mapped to actor-related control variables $\command$ using the \emph{control function} \texttt{getCommand}:

$\text{command} = \text{getCommand}(\text{situation})$

\item In robot soccer, $\command$ consists of the desired longitudinal and angular velocity of a player as well as instructions for his shooting device.
\item To enable not only reactive but also deliberative behavior, the behavior modules can create situation and command histories or use randomized procedures.
\end{itemize}

\paragraph*{Start and continue conditions}
\begin{itemize}
    \item Each \emph{behavior module} determines, in addition to its actual action, whether its preconditions are met and the behavior is therefore currently applicable at all using the so-called \emph{start condition} $\invCond$.
    \item A soccer player can only dribble the ball towards the goal, for example, if he is actually in possession of the ball.
    \item If a behavior module is active, it also returns whether all conditions are met to continue the behavior using the \emph{continue condition} $\comCond$.
    \item Because the player can only dribble on as long as he does not lose the ball or has reached the dribbling target.
    \item Or a more promising behavior such as a shot becomes possible.
    \item Each behavior module thus determines itself, using the start and continue conditions, whether it is applicable in the given situation.
    \item Therefore, the calling instance itself does not need any knowledge of the prerequisites for executing a behavior module.
\end{itemize}


\paragraph*{Behavior generation}
Generic \emph{arbitrators} combine a set of behavior modules, also referred to as options here, into a tactic
\begin{itemize}
\item First, the current situation $\situation$ is determined from the latest input data and is made available to the behavior modules
\item Next, the arbitrator determines its best applicable action
\item To do this, it filters out those options $\applicableOptions$ from its options $\options$ that are currently applicable or fall within the domain of the current situation
\item The behavior modules signal this via their start and continue conditions

\item From the applicable options $\applicableOptions$, the arbitrator finally selects the best possible option, defines it as its intention $\intention$
\end{itemize}

\subsection{Trajectory Planning}
Trajectory planning is the process of generating a trajectory that realizes a desired behavior or maneuver, given the current state of the vehicle and its environment. Trajectories can be modeled in continuous or discrete form and describe the Cartesian coordinates $(x, y)$ and orientation of a vehicle. Real-time trajectory planning methods typically only provide local solutions, so the maneuver decision is often separated from trajectory planning.

\subsubsection*{Methods}
A variety of methods are available for trajectory planning, including:
\begin{itemize}
    \item \textbf{Path Planning:} Determines the lateral guidance of the vehicle.
          \begin{itemize}
              \item \textbf{Graph Search Algorithms:} Used in free space, such as parking lots.
              \item \textbf{Dynamic Programming:} Used in scenarios with lanes.
              \item \textbf{Optimization:} Used to find a path that minimizes a cost function.
          \end{itemize}
    \item \textbf{Trajectory Planning:} Determines both the lateral and longitudinal motion of the vehicle.
          \begin{itemize}
              \item \textbf{Intelligent Driver Model (IDM):} A microscopic traffic flow model that describes the longitudinal behavior of drivers during car following.
              \item \textbf{Nonlinear Optimization:} Formulates a discrete, nonlinear optimization problem and solves it using numerical methods.
          \end{itemize}
\end{itemize}

\subsection{Fault-tolerant Systems}

Fault-tolerant systems are designed to maintain a high level of reliability despite potential faults or errors. In such systems, faults, errors, and failures are distinguished. Measures to increase reliability can be categorized into fault prevention, removal, tolerance, and prediction. Fault tolerance is a key pillar of reliable systems and encompasses fault diagnosis and fault handling. Fault handling methods include error recovery, error passivation, and error compensation.

\subsection{Traffic Safety}

\subsubsection*{Goal}
The goal of traffic safety is to ensure the absence of unreasonable risks when objects are moved in a (traffic) system.

\subsubsection*{Levels of Safety Analysis}
Safety analysis in traffic systems can be conducted at various levels:
\begin{itemize}
    \item \textbf{Hardware:} This involves ensuring the safety of the physical vehicle, sensors, actuators, computing platform, and cybersecurity measures.
    \item \textbf{Behavior:} Safety analysis at this level involves trajectory and behavior planning to ensure safe operation of the vehicle.
    \item \textbf{Fleet:} This encompasses the entire fleet of automated vehicles and related safety questions, such as fleet coordination and management.
\end{itemize}

\subsubsection*{Behavior Verification}
One of the challenges in traffic safety is verifying the safety of a planned behavior while considering uncertainties. A common method for behavior verification is the set-based approach with reachable sets analysis. This approach involves planning a fail-safe trajectory in addition to the intended trajectory. Worst-case occupancies are used to overapproximate possible behaviors of other traffic participants. The behavior is considered safe if the fail-safe trajectory does not overlap with worst-case occupancies. The benefits of this approach include provable safety under specified assumptions.

\subsubsection*{Overall Safety Approach}
An effective approach to ensuring traffic safety involves:
\begin{itemize}
    \item \textbf{Risk Analysis:} Identify and assess risks throughout the development process.
    \item \textbf{Verification and Validation:} Verify and validate safety at all levels, including hardware, behavior, and fleet.
    \item \textbf{Monitoring:} Continuously monitor risks during operation to ensure ongoing safety.
\end{itemize}