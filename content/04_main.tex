\section{Safe Arbitration Graphs}

In designing autonomous systems, the ideal scenario is one where each behavior component operates reliably under all conditions in which it could be called.
However, achieving this level of reliability is often impractical, especially when deploying these systems in complex and dynamic environments.
Real-world applications might involve numerous behaviors, implemented by different teams, which increases the likelihood of bugs and inconsistencies.
Consequently, ensuring the overall safety and robustness of such systems becomes a significant challenge.

In autonomous systems, the question of responsibility for safety is critical.
For individual behavior components, the responsibility typically falls on the developer who creates the component.
This responsibility is manageable when components are simple and isolated, but as systems grow in complexity, this approach does not scale well.
Additionally, in traditional approaches such as behavior trees, the system engineer will combine these behaviors into a coherent system bearing the responsibility for the system's safety.

To address these challenges, we propose a safety concept embedded directly into the arbitration graph framework.
With this approach, we aim to reduce the burden on both behavior component developers and system engineers.
This approach allows for more scalable and maintainable safety assurance, ensuring that even in the presence of unreliable or unsafe behaviors, the system as a whole remains robust and secure.

Before we discuss how to detect and mitigate unsafe and unreliable behaviors, we will first introduce the safety goals we aim to achieve with our approach:

\begin{itemize}
    \item The system ensures an safety action is executed whenever the operating conditions exceed the system's designed capabilities.
    \item The system is robust against behavior component failures
    \item The system prevents invalid control inputs
    \item The system avoids risky control inputs
\end{itemize}

\subsection{Detect Unsafe \& Unreliable Behaviors}
\begin{algorithm}
  \SetKwFunction{BestOption}{BestOption}%
  \SetKwProg{Fn}{function}{}{end}

  \Fn{\BestOption{situation $\situation$}}{\label{algo:verifying_arbitrator:bestOption}
    filter applicable options $\applicableOptions \subset \options$\;
    sort applicable options
      $\sortedApplicableOptions = \left< a_0, a_1, \dots \right> = \text{strategie}(\applicableOptions)$\;

    \For{$a \in \sortedApplicableOptions$}{
      get command $\command_a = \getCommand_a(\situation)$\;

      verify $\verification_a = \verifier (\command_a)$\;
      % \If(\tcp*[f]{Verifikation bestanden}){$\verification_a = 0$}{%
      \If{verification passed $\verification_a = 0$}{%
        \KwRet{$(\command_a, \verification_a)$}\;
      }
    }

    \KwRet{$(\emptyset, \text{NO\_SAFE\_OPTION})$}\;
    }
  \;
  \While{true}{
    determine current situation $\situation$\;\label{algo:verifying_arbitrator:situation}
    get $\verifiedCommand = (\command, \verification) = $ \BestOption{$\situation$}\;
    \If{verification passed $\verification_a = 0$}{
      execute $\command$\;
    % }{
    %   Gebe Fehlermeldung mit $\verification_a$ aus\;
    }
  }
  \caption{Generic arbitration procedure with verification \label{algo:verifying_arbitrator}}
\end{algorithm}
\begin{itemize}
    \item Basic arbitration graph that works in theory
    \item Might contain unsafe or unreliable behavior implementations
    \item Contains Chase, RunAway and Collect (EatClosest + GoToPatch) behaviors
    \item Example: EatClosest contains bug and throws exception when two or more closest pills exist
    \item Reference to paper title/research question: How to mitigate unsafe and unreliable behavior implementations?
    \item We could fix the bug in EatClosest but we want to show how to handle these scenarios in a more general way using Arbitration Graphs
    \item → Detect error and add RandomWalk as first fallback layer
\end{itemize}

\subsection{Unsafe}
Issues that arise due to logic errors. Output is executable but considered invalid or unsafe.
\begin{itemize}
    \item Random walk could output commands crashing into walls
    \item Domain specific verification step detects this → List examples from other domains
    \item Add dumb behavior (preferably so easy that it is proofably safe) as last resort fallback layer → StayInPlace
    \item StayInPlace does not have to pass verifier so Arbitration Graphs will always return a commnd
\end{itemize}
Discussion: StayInPlace could still be undesirable → Add additional fallback layers such as a duplicated RunAway (probably using other parameter).
